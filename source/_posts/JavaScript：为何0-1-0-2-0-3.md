---
title: JavaScript：为何0.1+0.2 != 0.3
date: 2022-05-21 14:49:00
tags:
    - JavaScript
    - 二进制
categories:
    - JavaScript进阶
---

# JavaScript 是怎样进行数字相加的

```javascript
console.log(0.1 + 0.2)
// 0.30000000000000004
```

-   十进制和二进制是如何相互转换的
-   浮点数是以什么格式存储的
-   计算机如何进行加法

## 进制转换 - 十进制转换二进制

-   整数：除 2 取余，逆序排列
-   小数：乘 2 取整，顺序排列

## 例：9.375

整数部分 9 -> 1001

```
    9 % 2  1
    4 % 2  0
    2 % 2  0
    1 % 2  1
    0
```

小数部分

```
    0.375 * 2 -> 0.75 -> 0
     0.75 * 2 -> 1.5  -> 1
      0.5 * 2 -> 1    -> 1
```

二进制表示：1001.011

## 进制转换 - 二进制转十进制

-   小数点前：<font color=red>从右到左</font>用二进制的每个数乘以 2 的相应<font color=red>次方递增</font>
-   小数点后：<font color=red>从左到右</font>用二进制的每个数乘以 2 的相应<font color=red>负次方递增</font>

![4-3-6](4-3-6.png)

整数部分： 1001 = 1\*2^0 + 0\*2^1 + 0\*2^2 + 1\*2^3 = 1 + 0 + 0 + 8 = 9  
小数部分： 011 = 0\*2^-1 + 1\*2^-2 + 1\* 2^-3 = 0 + 0.25 + 0.125 = 0.375

## 双精度 64 位浮点数

![4-3-7](4-3-7.png)

| 组成              | 描述                          | 位数  | 位置      |
| ----------------- | ----------------------------- | ----- | --------- |
| 符号位 Sign       | 符号，0 为正，1 为负          | 1bit  | b63       |
| 指数位 Exponent   | 指数部分，E=指数+1023(偏移码) | 11bit | b62 - b52 |
| 尾数部分 Fraction | 小数部分                      | 52bit | b51- b0   |

以 103.625 浮点数为例

![4-3-8](4-3-8.png)
![4-3-9](4-3-9.png)

## 浮点数运算

-   对阶
-   尾数运算
-   规格化
-   舍入处理
-   溢出判断

### 1. 浮点数运算 - 对阶

-   对阶-保持指数位数字一致
-   小阶对大阶

例：123.5 + 1426.00456 （以十进制为例去理解）

```
     1.235 * 10 ^ 2
    0.1235 * 10 ^ 3
1.42600456 * 10 ^ 3
```

#### 对阶-精度丢失问题

-   小阶对大大阶，小阶右移，容易丢失位数
-   相加或者相减，值可能溢出

### 2. 浮点数运算 - 对阶

-   尾数运算就是在完成对阶后进行尾数相加减

### 3. 浮点数运算 = 结果规格化

-   1.M 的形式 例子：17.051 -> 1.7051
-   左移规格化
-   右移规格化（精度可能丢失）

### 4. 浮点数运算 - 舍入处理

> 尾数右移时会丢失位数，而移出的位数会被暂时保存下来，在舍入处理时使用

-   舍入到最近（默认，1 入 0 舍）
-   朝 +∞ 方向舍入
-   朝 -∞ 方向舍入
-   朝 0 方向舍入

### 5. 浮点数运算 - 溢出判断

-   运算结果的阶码的值判断是否溢出
-   超过最大正数（上溢）：
    -   浮点数正数（正上溢）
    -   浮点数负数（负上溢）

---

# 0.1 + 0.2 != 0.3

IEEE 754 计算步骤

1. 对阶
2. 尾数运算
3. 结果规格化
4. 舍入处理
5. 溢出检查

## 换算成 IEEE 754 标准二进制结构

-   0.1 转二进制（小数转二进制）：直到乘积中的小数部分为 0

```
2 * 0.1
2 * 0.2     0

2 * 0.4     0
2 * 0.8     0
2 * 1.6     1
2 * 1.2     1

2 * 0.4     0
2 * 0.8     0
2 * 1.6     1
2 * 1.2     1

无限循环 0011
```

-   规格化：`0.0 0011 0011 (0011)n` => `1.1001 1001 (1001)n * 2^-4`
-   符号位：0
-   指数位：1023 + 指数 = 1019 (01111111011)
-   尾数位：由于无限循环，采用就近舍入（1 入 0 舍）保留 52 位，最后结尾 1001 => 1010

```
0.1 =>
0 | 01111111011 | 10011001 10011001 10011001 10011001 10011001 10011001 1010

0.2 =>
0 | 01111111100 | 10011001 10011001 10011001 10011001 10011001 10011001 1010
```

## 对阶

-   小阶对大阶
    -   0.1 的指数为 01111111011 = 1019
    -   0.2 的指数为 01111111100 = 1020
-   0.1 指数部分变为 1020，同时位数右移一位，尾数部分是 1.M 的形式

```
0.1 =>
0 | 01111111011 | 10011001 10011001 10011001 10011001 10011001 10011001 1010

0 | 01111111100 | 1 10011001 10011001 10011001 10011001 10011001 10011001 1010
```

## 位数运算

```
0.1 + 0.2 =>

 0. 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1101 0
 1. 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010
=>
10. 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0111 0
```

## 结果规格化

```
10. 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0111 0

 1.00110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0111 0
```

-   指数位+1，变为 1020+1=>1021，二进制：01111111101

## 舍入处理

```
1.0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 10 (54位)

1.0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0100
```

## 溢出检查

-   指数 1021 没有溢出

## 最终结果

-   符号位 S：0
-   指数位 E：0.1-1019，0.2-1020，计算后指数位 1021（1021，二进制：01111111101）
-   尾数位 M：0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0100

```
0 | 01111111101 | 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0100
```

结果为：
V = (-1)^S \* (1.M) \* 2^(E-1023)

1. (-1)^S = -1^0 = 1
2. 1.M \* 2^(1021-1023) = 0.30000000000000004
